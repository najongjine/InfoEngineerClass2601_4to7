package com.java_4to7;

class Animal{
	int hp=100;
	int food=10;
	
	public void attack() {
		System.out.println("할키기");
	}
	public void getName() {
		
	}
}
class Dog extends Animal{
	int hp=10;
	String name="닥터훈스";
	public void attack() {
		super.attack();
		System.out.println("물기");
	}
	public void getName() {
		System.out.println("name: "+name);
	}
}

public class Java260121 {
	public static void main(String[] args) {
		Animal animal=new Dog();
		animal.getName();
		
	}

}


------


package com.java_4to7;

class Animal{
	
	int hp=100;
	int food=10;
	String name="굼뱅이";
	
	static public void attack() {
		System.out.println("할키기");
	}
	public void getName() {
		
	}
}
/* 업캐스팅 -
 * 타입을 중점으로 두고 시작함.
 * 속성은 당연히 자기꺼 쓰고, 일반 메소드는 오버라이딩 되있나 체크만 해주면 됨
 * 일반 속성과 method는 new () 이걸 했을때, 뭘 갔다 쓸지 결정을 함
 * 하지만 static은 프로그램 시작전에 이미 만들어 져있기 때문에
 * overriding 이 안일어남

 this()- 자기 자신 클래스를 뜻함.
 super()- 부모를 뜻함
 자식에서 super.attack() 아니면 super() 이렇게 코드를 적으면
 부모에 있는 method나 생성자를 호출하게 되는것임
 
 부모가 자식에 있는 property에 접근하는 유일한 방법은
 method override 가 있다.
 *  */
class Dog extends Animal{
	int hp=10;
	String name="닥터훈스";
	static public void attack() {
		System.out.println("물기");
	}
	public void getName() {
		System.out.println("name: "+name);
	}
}

public class Java260121 {
	public static void main(String[] args) {
		Animal animal=new Dog();
		animal.attack();
		
	}

}


-----

package com.java_4to7;

/* 추상 클래스-
 * 얘는 가지 자신으로 구체화 못함
 * ex: new Animal() 안됨
 * 얘를 쓰고 싶으면 무조건 상속을 시켜줘야함 */
abstract class Animal{
	static String name="내발짐승";
	protected int hp=0;
	protected int food=10;
	Animal(){
		this.hp=10;
	}
	public void attack() {
		System.out.println("할퀴기");
	}
	abstract int getFood();
}
class Dog extends Animal{
	static String name="멍멍이";

	@Override
	int getFood() {
		// TODO Auto-generated method stub
		return food;
	}
}
class Cat extends Animal{
	static String name="야옹이";

	@Override
	int getFood() {
		// TODO Auto-generated method stub
		return food;
	}
}

public class Java260121 {
	public static void main(String[] args) {
		Animal dog=new Dog();
		Animal cat=new Cat();
		
		
	}

}



-----------


package com.java_4to7;

/* interface는 abstract class의 업그레이드판
 * interface 단독으로 구체화 못시키고
 * interface 안에서 함수 구체화 못시켜요
 * interface 안에 만든 속성은 무조건 static final이 되요 */
interface Animal{
	int hp=10; // static final 이라서 변경 불가능.
	public void makeSound();
	public void attack();
}
interface Pest{
	public void drinkBool();
	public void disease();
}


/* interface는 여러개 상속 받을수 있어요. */
class Dog  implements Animal, Pest{

	@Override
	public void drinkBool() {
		System.out.println("벼룩이 개 피 빨아먹음");
	}

	@Override
	public void disease() {
		System.out.println("개 몸안에 기생충 낳음");
		
	}

	@Override
	public void makeSound() {
		System.out.println("멍멍");
	}

	@Override
	public void attack() {
		System.out.println("물기");
	}
	
}

public class Java260121 {
	public static void main(String[] args) {
		/* type이 Animal. Dog class에 능력이 4개 있지만,
		 * Animal type엔 능력이 2개밖에 없어서
		 * dog. 찍으면 2개밖에 안보여요 */
		Animal dog=new Dog();
		Pest dog2= new Dog();
		
		/* Dog type은 능력이 4개니깐 4개 다 보여요  */
		Dog dog3=new Dog();
		
	}

}


------

package com.java_4to7;

interface Soundable{
	void sound();
	void move();
}

class Dog implements Soundable{
	public void sound() {
		System.out.println("멍멍");
		
	}
	public void move() {
		System.out.println("강아지가 네발로 뛰어감");
		
	}
}
class Bird implements Soundable{
	public void sound() {
		System.out.println("짹짹");
		
	}
	public void move() {
		System.out.println("새가 푸드덕 날아감");
		
	}
}

public class Java260121 {
	public static void main(String[] args) {
		
		
	}

}
