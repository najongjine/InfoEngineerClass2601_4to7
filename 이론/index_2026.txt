XP, 에자일, Scrum, 폭포수, 나선형
p28

구조적 방법론, 정보공학 방법론, 객체지향 방법론, 컴포넌트기반 방법론, 애자일 방법론
p34

일정산정 PERT, CPM, 간트차트
p41

usecase 유스케이스
p61
https://wildojisan.tistory.com/117


HIPO, NS
p67

동료 peer 검토, 워크스루 walk through 컴토, 인스펙션 inspection 검토
p69

UML 일반화관계 집합관계 연관관계 gillamet, stereo type, 구조적 diagram, 행위 diagram
소프트웨어 아키텍처 pip-filter 패턴, broker 패턴, peer to peer 패턴, MVC 패턴
p72

구조,정적 다이어그램
멈춰있는 뼈대 (클래스)
p75

행위,동적 다이어그램
움직이는 순서 (시퀀스, 유스케이스)
p76

기능(럼바우) = 자료 흐름도(DFD)
p66

Middleware 미들웨어, WAS 웹서버, 연동오류예측 생략오류 필사오류 전위오류 이중오류
p59, 109

EAI
p169

상향식 통합 driver, 하향식 통합 stub, test harness
p201

응집도 결합도
p97

디자인패턴
p345
https://wildojisan.tistory.com/151
https://github.com/najongjine/Engineer_Information_Processing_TestClass_2509/blob/main/Day17_java.txt

객체지향 E-R diagram Coad-Yourdon
p344

DB E-R diagram
p233

cocomo, putnam, loc, 기능점수 비용산정
p46

case, cmm, cmmi, spice, git 형상관리
p51

DRM
p181

git, svn, cvs
p189

물리데이터베이스설계, 파티션, 스토리지, DAS, NAS, SAN, Range, Hash
참조 무결성, 개체 무결성, 도메인 무결성
p288

분산데이터베이스, 위치투명성, 분할투명성, 중복투명성, 장애투명성, 병행투명성
p292

임의겁근통제 DAC, 강제접근통제 MAC
p294

반정규화
p301

낚시의 법칙, Pareto, 살충제 paradox, 오류 부재의 궤변
정적테스트, 동적테스트
p194




화이트박스 테스트, 블랙박스 테스트
p196
* 블랙박스 테스트(Black Box Testing) : 입력값을 넣었을 때 원하는 결과가 나오는가?
    1. 동치 분할 검사 (Equivalence Partitioning Testing)
        핵심: "대표값 하나만 뽑아서 테스트하자."

        실무 예시:

            입력 범위: 1 ~ 100

            테스트 케이스 1: 50 (정상 그룹 대표 - 통과해야 함)

            테스트 케이스 2: -10 (비정상 그룹 대표 - 에러 떠야 함)

            테스트 케이스 3: 200 (비정상 그룹 대표 - 에러 떠야 함)

    2. 경계값 분석 (Boundary Value Analysis) ★중요
    핵심: "에러는 항상 끝부분(경계)에서 터진다."

    실무 예시: (1 ~ 100 입력 시)

        0, 1 (최소 경계)

        100, 101 (최대 경계)

        이렇게 경계선 좌우의 값을 집중적으로 찌릅니다.

    3. 원인-효과 그래프 검사 (Cause-Effect Graphing Testing)

    원리: 입력 조건(원인)과 그에 따른 출력 결과(효과) 간의 논리적 관계를 **그래프(도표)**로 그려서 테스트 케이스를 만듭니다.

   

    4. 오류 예측 검사 (Error Guessing)
    핵심: 사람의 직감, 촉

    논리: "개발자들이 보통 여기서 실수하더라", "특수문자를 넣으면 보통 뻗더라" 하는 과거의 경험적 데이터를 바탕으로 취약할 것 같은 곳을 핀포인트로 공격합니다. 공식적인 기법으로 못 찾는 버그를 찾을 때 씁니다.

    5. 비교 검사 (Comparison Testing)
    핵심: 버전업 했을시, "구버전과 신버전의 결과가 같은지 비교."



*화이트 박스는 테스트 하는 방법과 얼마나 빡세게 할거냐 라는 2 그룹이 있고, 기초경로 검사하면 러버리지 레벨 2 까지만 하는거다. 제어구조 검사 방법 쓰면 레벨 5까지 할수있다.

* 기초 경로 검사 (Base Path Testing). 테스트하는 방법 (큰 기술)

대표적인 화이트박스 테스트 기법이다.
프로그램 내의 **모든 명령문과 모든 분기(갈림길)**를 최소한 한 번씩은 거쳐가는 경로만 골라서 테스트

* 제어 구조 검사 (Control Structure Testing). 테스트하는 방법 (큰 기술)
기초 경로 검사 "도로(길) 전체를 한 번 훑는 것" 이라면,
제어 구조 검사는 그 길 위에 있는 "신호등(If), 회전교차로(Loop), 표지판(변수)" 같은 특정 장치들이 고장 안 났나 집중적으로 패는 것

    ..조건 검사(Condition Testing):
    프로그램의 논리, 즉 IF 문(조건)을 집중 타격합니다.

    상황: 만약 (나이가 19세 이상) AND (티켓이 있다) 라면 입장

    테스트:

        나이만 어려보기

        티켓만 없애보기

        둘 다 없애보기

        나이 19세 딱 맞춰보기 (경계값)

    목표: 이 조건문(신호등)이 빨간불/초록불을 제대로 켜는지 확인.

    ..루프 검사(Loop Testing):
    FOR문이나 WHILE문 같은 반복 구간을 괴롭히는 겁니다.
    테스트: 10바퀴 뛰는 코드

        0바퀴: 아예 시작도 안 해봄 (건너뛰기)

        1바퀴: 딱 한 번만 실행해봄

        10바퀴: 정해진 횟수 채워봄

        100억 바퀴: 일부러 미친 듯이 돌려봄 (다운되나 안 되나)
    목표: 계속 돌다가 프로그램이 뻗는지, 시작하자마자 죽는지 확인.

    ..데이터 흐름 검사(Data Flow Testing):
    코드 안의 변수(데이터) 하나를 정해서 스토킹하는 겁니다.
    테스트: x라는 변수가 있다.

        x 값이 어디서 처음 생겼지? (정의)

        x 값이 어디서 계산에 쓰였지? (사용)

        어? x에 값을 넣지도 않았는데 더하기를 하네? (오류 발견)

    목표: 이상하게 쓰이는 변수가 없는지 확인.


* 화이트박스 커버리지:
if (A and B):    # 조건문 (결정 포인트)
    print("실행!") # 구문

1. 구문 커버리지 (Statement Coverage)
    목표: 코드 내부의 print("실행!")을 최소 1번은 실행시켜야 함.

    논리: if문이 True가 되는 케이스 딱 1개만 있으면 됨.

    테스트 케이스:

    A=True, B=True → 결과: True (실행됨)

설명: False인 상황은 아예 테스트 안 함.

2. 결정 커버리지 (Decision Coverage) = 분기 커버리지
    목표: if문의 **최종 결과(Result)**가 True인 경우와 False인 경우를 각각 최소 1번씩 확인.

    논리: (A and B) 전체 덩어리의 결과값(T/F)에만 집중.

    테스트 케이스 (예시):

    A=True, B=True → 결과: True

    A=True, B=False → 결과: False

    특징: 전체 결과만 신경 쓰고, A나 B가 각각 True/False를 다 가졌는지는 따지지 않음.

3. 조건 커버리지 (Condition Coverage) 🔥(가장 헷갈리는 부분)
    목표: 괄호 안의 **개별 조건 변수(A, B)**가 각각 True 한 번, False 한 번씩 값을 가져봐야 함.

    논리: 전체 결과가 True냐 False냐는 중요하지 않음. A가 T/F 다 해봤나? B가 T/F 다 해봤나? 이것만 봄.

    테스트 케이스 (함정 케이스):

    A=True, B=False → (개별조건: A는 T, B는 F) → 전체결과: False

    A=False, B=True → (개별조건: A는 F, B는 T) → 전체결과: False

    맹점: 위 두 케이스를 보면 A, B는 각각 T/F를 다 경험했지만, 정작 if문의 전체 결과는 둘 다 False입니다. 즉, 구문(Print문)이 실행되는 길은 테스트를 못한 셈이 됩니다.

    요약: 개별 조건은 만족시켰으나, 분기(결정) 검증에 실패할 수 있음.

4. 조건/결정 커버리지 (Condition/Decision Coverage)
    목표: 위 3번의 맹점을 보완. "개별 조건(A,B)도 T/F 다 찍고" + "전체 결과도 T/F 다 찍자"

    논리: 교집합. 2번과 3번 조건을 모두 만족하는 케이스를 선정.

    테스트 케이스:

    A=True, B=True → (개별 다 만족, 전체 결과 True)

    A=False, B=False → (개별 다 만족, 전체 결과 False)

    설명: 가장 합리적으로 꼼꼼한 단계.

5. 다중 조건 커버리지 (Multiple Condition Coverage)
    목표: 진리표(Truth Table)의 모든 경우의 수를 다 테스트.

    논리: 2^N (조건이 2개면 2^2 = 4가지).

    테스트 케이스 (완벽):

    A=True, B=True

    A=True, B=False

    A=False, B=True

    A=False, B=False

    설명: 빠져나갈 구멍이 없음. 가장 강력함.



테스트 오라클 test oracle
p198

자료구조, 선형구조, 비선형구조, 알고리즘, 탐욕적, 근사, 분활 깊이우선 DFS,
스택, Q, 전위식 후위식, deQ, tree, graph
p134

탐색 검색 빅O
p137

정규화
p241

DB 병행제어, locking, recovery
p279

DB 도메인 튜블 relation 속성, key, 스키마, degree cardinality
p217

* 비동기식 - "글자 하나하나 낱개 포장"
가장 중요한 건 **'Start 비트'**와 **'Stop 비트'**입니다.

상황: 이삿짐을 옮기는데, 짐을 트럭에 한 번에 싣는 게 아니라 상자 하나 들고 뛰었다가, 쉬었다가, 또 상자 하나 들고 뛰는 방식입니다.

특징:

상자(글자) 하나 보낼 때마다 "자 간다(Start Bit 0)", **"도착했다(Stop Bit 1)"**라고 신호를 줘야 합니다.

앞뒤로 신호를 붙이니 느립니다. (오버헤드 발생)

상자와 상자 사이에 **쉬는 시간(Idle Time)**이 있습니다.

시험 족보: [문자 단위], [Start/Stop 비트], [저속], [유휴 시간] 나오면 무조건 비동기입니다.


* 동기식 - "컨테이너에 꽉 채워서 한방에"
가장 중요한 건 **'클럭(Clock/박자)'**과 **'프레임(Frame/묶음)'**입니다.

상황: 이삿짐을 컨테이너 트럭(프레임) 하나에 빈틈없이 꽉꽉 채워서 한 번에 쏘는 방식입니다.

특징:

"시작/끝" 신호를 매번 안 줍니다. 대신 **박자(Clock)**에 맞춰서 기계적으로 우루루 보냅니다.

군더더기(Start/Stop)가 없으니까 빠릅니다.

데이터를 묶은 덩어리를 **프레임(Frame)**이라고 부릅니다.

시험 족보: [프레임/블록 단위], [클럭(Clock)], [고속], [대용량] 나오면 무조건 동기입니다.



동기식전송제어문자 SYN ACK NAK, 네트워크장비 Hub Repeater Bridge, Switch, Router, Gateway
p416

전진오류제어 Hamming code, 후진오류제어 parity bit, crc, 다항식 코드, ARQ
p418

다중화기 MUX, 집중화기 Concentrator, CSMA, 네트워크 토폴로지 star bus ring tree mesh
p422
CSMA의 핵심 원리
CSMA의 기본 동작은 사람이 대화할 때처럼 "말하기 전에 듣는" 방식입니다.

Carrier Sense (반송파 감지): 데이터를 전송하려는 장치는 먼저 통신 매체(채널)를 '듣습니다'. 즉, 다른 장치가 현재 데이터를 전송 중인지(캐리어 신호가 감지되는지) 확인합니다.

사용 중(Busy)이면: 전송을 미루고 대기합니다.

사용 중이 아니면(Idle): 데이터를 전송합니다.

Multiple Access (다중 접근): 네트워크에 연결된 여러 장치(노드)가 이 매체를 공유하여 데이터를 전송할 수 있음을 의미합니다.

CSMA 자체는 동시에 여러 장치가 채널이 비어 있다고 판단하여 전송을 시작할 때 발생하는 **충돌(Collision)**을 완전히 막지 못합니다. 이 충돌을 처리하기 위해 다음과 같은 두 가지 방식이 추가됩니다.

1. CSMA/CD (Collision Detection, 충돌 탐지)
사용 환경: **유선 LAN (이더넷, Ethernet)**에서 주로 사용됩니다.

원리:

채널을 감지하여 비어 있으면 데이터를 전송합니다.

전송 중에도 충돌이 발생했는지 계속 감지(Detection)합니다.

충돌이 감지되면 즉시 전송을 중단하고 잼(Jam) 신호를 보냅니다.

이후 백오프(Backoff) 알고리즘을 사용하여 임의의 시간 동안 기다린 후 재전송을 시도합니다.

2. CSMA/CA (Collision Avoidance, 충돌 회피)
사용 환경: **무선 LAN (Wi-Fi)**에서 주로 사용됩니다.

원리: 무선 환경에서는 충돌을 정확히 감지하기 어렵기 때문에(Hidden Node 문제 등), 충돌 자체를 미리 피하는(Avoidance) 전략을 사용합니다.

채널 감지 후에도 **추가적인 대기 시간(DIFS, SIFS)**을 갖습니다.

데이터를 보내기 전에 RTS (Request to Send) 패킷을 보내고, 수신자로부터 CTS (Clear to Send) 응답을 받으면 그때 데이터를 전송합니다. 이는 주변의 다른 노드들에게 통신이 시작됨을 알려 충돌을 회피하도록 합니다.





패킷교환방식 가상회선 datagram
p425

라우팅 프로토콜 RIP OSPF
p428

OSI 7계층, TCP UDP, IP, IPSEC
p429
https://wildojisan.tistory.com/152
https://www.youtube.com/watch?v=66lp--WeGpc

IPv4, IPv6, subnet
p437

chmod
p386
읽기	r	4
쓰기	w	2
실행	x	1
권한 없음	-	0

사용자 (User)	읽기, 쓰기, 실행 (rwx)	4 + 2 + 1	7
그룹 (Group)	읽기, 실행 (r-x)	4 + 0 + 1	5
그 외 (Others)	실행 (---x)	0 + 0 + 1	1


프로세스 상태 ready wait run pcb, thread, process scheduling FIFO RR HRN SRT MFQ
p392

상호배제 Mutex, 세마포어 Semaphore, 교착상태, 은행원 알고리즘
p396
세마포어의 기본 개념
P 연산 (wait, 대기):

자원을 사용하려고 할 때 수행해요.

세마포어 값을 1 감소시켜요.

만약 감소시킨 후 값이 음수라면, 자원을 사용할 수 없으므로 해당 프로세스(또는 스레드)는 대기(잠금) 상태로 전환됩니다.

화장실 비유: 열쇠를 가져가는 행위. 열쇠가 없으면 줄을 서서 기다려야 합니다.

V 연산 (signal, 신호):

자원 사용을 마쳤을 때 수행해요.

세마포어 값을 1 증가시켜요.

만약 증가시키기 전 값이 음수였다면, 대기 중인 프로세스(또는 스레드)가 있다는 뜻이므로 그 중 하나를 **해제(잠금 해제)**시켜 자원을 사용하게 합니다.

화장실 비유: 사용 후 열쇠를 반납하는 행위. 기다리는 사람이 있으면 그 사람에게 열쇠를 넘겨줍니다.



기억장치 배치전략 최초적합 최적적합, 단편화
p398

가상기억장치 페이징 세그먼테이션, 페이지 교체 알고리즘 FIFO, LRU, LFU, NUR, working set, thrashing
p400

바이러스 ddos, troy, worm, smurf, hijack
p471

객체지향 SOLID
https://devinus.tistory.com/13


최신기술
p441


보안솔루션, 방화벽, 차단, 방지 tripwire 
p482




1. 개념적 설계 (Conceptual Design)  ER Diagram
 
목표: 
현실 세계의 데이터를 컴퓨터에 저장할 수 있는 형태로 추상화하여 개념 스키마를 설계하는 단계입니다.
주요 활동:
관리해야 할 데이터(개체)와 그 속성(값)을 식별합니다.
개체와 속성 간의 관계를 나타내는 ER 다이어그램(개체-관계 모델)을 작성합니다.
트랜잭션 모델링을 정의하여 데이터베이스와 사용자 간의 데이터 교환 단위를 정의합니다.
 

2. 논리적 설계 (Logical Design)   정규화
 
목표: 
개념적 설계 단계에서 만들어진 모델을 특정 데이터 모델(주로 관계형 데이터 모델)에 맞게 변환하여, 논리적인 구조를 가진 데이터베이스 스키마(스키마)를 설계하는 단계입니다.
주요 활동:
ER 다이어그램을 관계형 데이터 모델의 릴레이션(테이블)으로 변환하고, 릴레이션 스키마를 정의합니다.
데이터 간의 관계를 테이블 간의 관계로 나타내고, 데이터 무결성을 위한 제약 조건 등을 명시합니다.

3. 물리적 설계 (Physical Design)    CREATE INDEX
 
목표: 
논리적 설계에서 정의된 스키마를 실제 저장 장치(하드디스크 등)에 효율적으로 저장하기 위한 물리적인 데이터 구조를 결정하는 단계입니다.
주요 활동:
저장 레코드 양식을 설계하고, 데이터가 저장될 물리적 공간을 결정합니다.
응답 시간, 저장 공간 효율성, 트랜잭션 처리량 등 성능 관련 요소를 고려합니다.
데이터에 빠르게 접근하기 위한 인덱스(색인) 생성 여부를 결정하고, 접근 경로를 설계합니다.



1. 외부 스키마 (External Schema)
한마디로: "사용자(나)가 보는 화면"

쉬운 설명: 내가 쿠팡 앱을 켰어요. 나는 상품명, 가격, 내 장바구니만 보이죠? 내 친구가 관리자 페이지로 접속하면 재고 현황, 반품율, 매출액이 보일 겁니다.

사용자(나)에게는 "내 정보"만 보여야지, 남의 비밀번호나 회사의 전체 매출 장부가 보이면 안 되잖아요?

이렇게 **"개개인이나 특정 프로그램이 필요한 데이터만 보여주는 껍데기"**가 외부 스키마입니다.

💻 CS / 실제 DB 연결:

SQL의 VIEW: 실제 테이블은 하나지만, 개발자가 CREATE VIEW를 통해 사용자용 뷰(상품 목록)와 관리자용 뷰(매출 통계)를 따로 만들어 제공하는 것과 같습니다.

여러 개 존재할 수 있습니다. (사용자용, 관리자용, 배송기사용 등등)

2. 개념 스키마 (Conceptual Schema) ← 이게 정답!
한마디로: "전체 데이터의 설계도 (총괄 사장님 관점)"

쉬운 설명: 사용자는 앱 화면만 보지만, 쿠팡 전체 시스템을 총괄하는 사람은 모든 데이터를 다 알아야 합니다.

"우리 쇼핑몰에는 '회원', '상품', '주문'이라는 데이터 덩어리가 있고, 회원이 상품을 사면 '주문'이 된다."

이렇게 모든 데이터의 구조, 관계, 규칙을 정의해 놓은 '단 하나'의 전체 지도입니다.

💻 CS / 실제 DB 연결:

ER 다이어그램(ERD) & CREATE TABLE: DB 설계 단계에서 만드는 전체 테이블 정의서입니다.

"Member 테이블엔 ID(PK)가 있고, Order 테이블과 1:N 관계를 맺는다"라는 논리적 구조 그 자체입니다.

DB 하나당 딱 1개만 존재합니다.

3. 내부 스키마 (Internal Schema)
한마디로: "실제 하드웨어에 저장되는 방식 (창고 정리법)"

쉬운 설명: 개념 스키마가 "무엇을 저장할까"라면, 내부 스키마는 **"컴퓨터 하드디스크 어디에, 어떻게 저장할까?"**입니다.

"상품 가격 데이터는 숫자가 크니까 8바이트로 압축해서 저장하고, 검색을 빠르게 하려고 '가나다' 순으로 인덱싱을 해서 A구역 하드디스크에 박아라."

💻 CS / 실제 DB 연결:

파일 시스템 & 인덱싱: 데이터가 실제 SSD나 HDD에 저장될 때의 레코드 구조, 필드의 크기(Byte), 인덱스(B-Tree, Hash) 구현 방법 등을 말합니다.

시스템 프로그래머나 시스템 설계자가 보는 관점입니다.



* 범위 분할 (Range Partitioning)
가장 직관적이고 많이 쓰이는 방식입니다. 데이터가 가지는 연속적인 **'범위'**를 기준으로 나눕니다.

쉬운 예시: 학교 성적표 데이터베이스를 만들 때, 0~50점은 A 파티션에, 51~100점은 B 파티션에 넣는 방식입니다. 또는 회사 매출 데이터를 1~3월(1분기), 4~6월(2분기)처럼 날짜 단위로 나누는 것도 범위 분할입니다.

시험 키워드:

지정된 범위 (연속적인 숫자, 날짜 기준)

관리의 용이성

이력 데이터(Historical Data) 관리에 적합


* 해시 분할 (Hash Partitioning)
데이터를 어디에 넣을지 사람이 정하는 게 아니라, **'해시 함수'**라는 수학적 공식에 맡겨서 골고루 흩어지게 하는 방식입니다.

쉬운 예시: 수백만 명의 고객 데이터가 있을 때, 특정 서버에만 데이터가 몰리지 않도록 고객의 '주민번호'나 'ID'를 해시 함수에 통과시킵니다. 그러면 4개의 파티션(서브DB)에 데이터가 아주 골고루(균등하게) 나뉘어 저장됩니다. (단, 특정 데이터가 어느 파티션에 있는지 직관적으로 알기는 어렵습니다.)

시험 키워드:

해시 함수 (Hash Function)

데이터의 균등한 분산 (분배)

특정 데이터가 어디에 속하는지 명시적 제어 불가


* 목록 분할 (List Partitioning)
범위로 나누기 애매한, 딱딱 끊어지는(이산적인) 데이터들을 **특정 값의 '목록'**으로 묶어서 나누는 방식입니다.

쉬운 예시: 전국 고객 데이터를 나눌 때 숫자로 나누기 애매하죠. 이때 "A 파티션에는 (서울, 인천, 경기)를 넣고, B 파티션에는 (부산, 울산, 경남)을 넣어라!"라고 사람이 직접 목록을 정해주는 방식입니다.

시험 키워드:

명시적 제어 (사용자가 직접 데이터가 들어갈 파티션을 지정)

특정 값의 목록 (List)

분포도가 비선형적이거나 이산적(불연속적)일 때 적합


* 조합 분할 (Composite Partitioning)
위에서 배운 두 가지 이상의 파티셔닝 기법을 섞어서 쓰는 방식입니다. 데이터가 무지막지하게 클 때 사용합니다.

쉬운 예시: 먼저 전체 데이터를 '가입 연도'를 기준으로 나눕니다 (범위 분할). 그런데 2023년 가입자만 1천만 명이라서 데이터가 너무 큽니다. 그래서 2023년 파티션 안에서 다시 고객 ID를 기준으로 해시 함수를 돌려 여러 개로 잘게 쪼갭니다 (해시 분할).

시험 키워드:

두 가지 이상의 분할 기법 결합

메인 파티션과 서브 파티션 (Main-Sub)

대용량 데이터(VLDB)에 주로 사용




ICMP (ping)
데이터가 전송 경로의 문제(예: 너무 큰 패킷, 도달 불가능한 목적지)로 인해 제대로 전달되지 않았을 때, 해당 문제를 원래 발신자에게 알려주는 역할을 합니다.
ping: 두 기기 간의 네트워크 연결 상태를 확인하고, 데이터가 왕복하는 데 걸리는 시간을 측정합니다.
traceroute: 데이터가 목적지까지 도달하기 위해 거쳐 가는 모든 라우터 경로를 보여줍니다.


럼바우(Rumbaugh) 분석 기법 (객체 모델링 기법(OMT, Object Modeling Technique)).  설계 기법
1. 객체 모델링 (Object Modeling)  -> 정적 다이어그램 (클래스 다이어그램)
시스템의 데이터 구조를 객체 중심으로 모델링합니다. 
클래스, 속성, 연산 및 클래스 간의 관계를 정의하고, 객체 모형으로 표현합니다. 
상태 다이어그램은 사용되지 않습니다.

2. 동적 모델링 (Dynamic Modeling) -> 동적 다이어그램 (상태 다이어그램)
객체 간의 상호작용과 시나리오를 모델링합니다. 
상태 다이어그램을 사용하여 객체의 동적인 행위를 표현하며, 이벤트 변화를 중심으로 객체들이 어떻게 상태를 변화시키는지 기술합니다. 

3. 기능 모델링 (Functional Modeling)
시스템의 기능적인 측면을 모델링합니다. 
자료 흐름도(DFD)를 사용하여 시스템의 입출력과 프로세서들의 처리 과정을 기술합니다. 


정적 다이어그램 동적 다이어그램.   그림 그리기 종류
1. 정적 다이어그램 (Structural Diagrams)
정의: 시스템의 구조와 정적인 관계를 표현하며, 변하지 않는 소프트웨어 요소의 논리적 구조를 보여줍니다. 
주요 다이어그램:
클래스 다이어그램: 클래스, 속성, 메서드, 그리고 클래스 간의 관계(상속, 연관, 의존 등)를 표현합니다. 
객체 다이어그램: 특정 시점의 객체 인스턴스와 그들 사이의 관계를 표현합니다. 
컴포넌트 다이어그램: 시스템의 물리적인 구성 요소인 컴포넌트들과 그들의 관계를 보여줍니다. 
2. 동적 다이어그램 (Behavioral Diagrams)
정의: 소프트웨어가 실행될 때 시간의 흐름에 따라 변경되는 동적인 측면과 객체 간의 상호작용을 모델링합니다. 
주요 다이어그램:
유스케이스 다이어그램: 시스템이 제공하는 기능(유스케이스)과 이를 사용하는 외부 행위자(액터) 간의 관계를 표현합니다. 
시퀀스 다이어그램: 시간 순서에 따라 객체들 간에 교환되는 메시지의 흐름을 보여줍니다. 
활동 다이어그램: 비즈니스 프로세스나 알고리즘의 실행 흐름을 활동과 상태를 통해 표현합니다. 
상태 머신 다이어그램: 객체가 가질 수 있는 다양한 상태와 상태 변화를 위한 조건(이벤트)을 보여줍니다. 


자료구조 트리 tree
루트 노드 (Root Node): 트리의 최상단에 위치하며, 가장 높은 레벨인 0번 레벨에 해당합니다.
레벨 증가: 루트 노드의 바로 아래 자식 노드들은 레벨 1, 그 다음 레벨의 노드는 레벨 2, 이런 식으로 아래로 내려갈수록 레벨이 1씩 증가합니다.
최대 레벨 (트리 높이): 트리가 가지는 가장 높은 레벨을 말하며, 트리의 깊이를 나타내는 중요한 지표입니다.
단말 노드 (Leaf Node): 자식이 더 이상 없는 노드로, 트리의 가장 끝에 위치하는 노드들입니다.
자식 노드 (Son Node): 특정 노드의 바로 아래에 연결된 하위 노드를 의미합니다.
부모 노드 (Parent Node): 특정 노드의 바로 위에 연결된 상위 노드를 의미합니다


해싱 함수 hashing
https://velog.io/@tjrdbfl123/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC-%ED%95%B4%EC%8B%B1%ED%95%A8%EC%88%98
1) 제산법(Division)
: 레코드 키로 해시표의 크기보다 큰 수 중에서 가장 작은 소수로 '나눈' 나머지를 홈 주소로 삼는 방식

2) 제곱법(mid-square)
: 레코드 키 값을 제곱

3) 폴딩법(중첩법)
: XOR

4) 기수 변환법
: 키 숫자의 진수를 다른 진수로 변화시켜 주소 크기를 초과한 높은 자릿수를 절단하고, 이를 다시 주소 범위에 맞게 조정하는 방법

5) 계수 분석법(숫자 분석법)
: 키 값을 이루는 숫자의 분포를 '분석'하여 비교적 고른 자리를 필요한 만큼 선택해서 홈 주소로 삼는 방식

6) 대수적 코딩법
: 키 값을 이루고 있는 각 자리의 비트 수를 한 다항식의 계수로 간주하고, 이 다항식을 해시표의 크기에 의해 정의된 다항식으로 나눙 얻은 나머지 다항식의 계수를 홈 주소로 삼는 방식



데이터베이스 이상현상
삽입 이상(Insertion Anomaly): 새로운 데이터를 테이블에 추가할 때, 다른 데이터의 정보가 누락되어 삽입이 불가능해지는 현상. 
예시: 어떤 과목을 수강하는지 정보가 없는 학생의 경우, 학생의 정보를 입력하더라도 과목 정보가 함께 입력되지 않아 삽입이 되지 않는 경우. 

삭제 이상(Deletion Anomaly): 특정 데이터를 삭제할 때, 의도하지 않은 다른 데이터까지 함께 삭제되어 정보가 손실되는 현상. 
예시: 한 학생이 들은 과목 중 하나의 과목 정보를 삭제할 때, 해당 학생의 다른 모든 정보까지 함께 삭제되어 버리는 경우. 

갱신 이상(Update Anomaly): 같은 데이터가 여러 테이블에 중복 저장되어 있어, 특정 데이터를 갱신할 때 일부 데이터만 갱신되고 나머지는 갱신되지 않아 데이터의 불일치가 발생하는 현상. 
예시: 동일한 학생의 전화번호를 갱신할 때, 일부 행의 전화번호만 수정되고 다른 행의 전화번호는 수정되지 않아 혼란을 야기하는 경우. 

이상현상 해결은 정규화를 통해서 한다


DB ACID 
원자성 (Atomicity): 트랜잭션 내의 모든 연산이 성공적으로 실행되거나, 하나도 실행되지 않아야 합니다. 부분적으로만 완료되는 것이 아니라, 전체가 성공하거나, 아니면 모두 실패하여 이전 상태로 돌아가야 합니다. 
일관성 (Consistency): 트랜잭션이 실행되기 전의 데이터베이스 상태와, 실행이 완료된 후의 상태가 항상 일관성을 유지해야 합니다. 즉, 시스템의 제약 조건은 그대로 유지되어야 합니다. 
격리성 (Isolation): 여러 트랜잭션이 동시에 실행될 때, 각 트랜잭션은 서로 영향을 주지 않고 독립적으로 실행되는 것처럼 동작해야 합니다. 마치 다른 트랜잭션이 존재하지 않는 것처럼, 각자의 작업에만 집중할 수 있도록 보장합니다. 
영속성 (Durability): 트랜잭션이 성공적으로 완료(커밋)되면, 데이터베이스의 변경 사항은 영구적으로 저장되어야 합니다. 시스템 오류나 비정상적인 종료가 발생하더라도, 이미 완료된 트랜잭션의 결과는 유지되어야 합니다. 


DB 관계대수 관계해석
https://sugoring-it.tistory.com/231


IP class A B C subnet
https://sssinga.tistory.com/entry/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC-%EA%B3%84%EC%82%B0%EC%8B%9D-IP%ED%81%B4%EB%9E%98%EC%8A%A4



데이터 접근 권한을 통제 DAC MAC RBAC
https://pth6510.tistory.com/18

MAC (강제적 접근 통제) 상세 설명

객체(파일) 등급: 보고서 파일에 **'일급 기밀'**이라는 보안 등급이 붙어 있습니다.

주체(사용자) 등급:

병사 A: 보안 등급이 **'일반'**입니다.

장군 B: 보안 등급이 **'일급 기밀'**입니다.

통제: 시스템은 병사 A가 파일에 접근하려고 하면, 등급이 낮기 때문에 파일 소유자가 허락했더라도 접근을 강제로 거부합니다. 장군 B만 접근이 허용됩니다.


DAC (임의적 접근 통제) 상세 설명

소유자: 당신이 보고서.docx 파일을 만들었습니다. 당신이 이 파일의 소유자입니다.

권한 부여: 당신은 이 파일을 **"팀장님에게는 읽기와 쓰기 권한"**을 주고, "팀원에게는 읽기 권한만" 주는 등 권한을 자유롭게 설정할 수 있습니다.

자유로운 변경: 언제든지 마음이 바뀌면 팀원에게 주었던 권한을 취소하거나 변경할 수 있습니다.


RBAC 

권한 설정: 관리자는 먼저 조직에 필요한 역할을 정의하고, 각 역할에 필요한 최소한의 권한을 할당합니다.

역할: '인사 담당자'

권한: '직원 급여 정보 조회', '직원 입사/퇴사 기록 수정'

역할: '영업 사원'

권한: '고객 계약 정보 조회/수정', '개인 실적 보고서 작성'

사용자 할당: 신입 사원이 입사하면, 그 사람에게 '인사 담당자' 역할을 할당해 줍니다.

접근: 이 사용자는 자신이 맡은 '인사 담당자' 역할 덕분에 급여 정보에 접근할 수 있지만, '영업 사원'의 권한(고객 계약 정보)은 가질 수 없습니다.



VPN
제시된 내용은 **VPN(Virtual Private Network, 가상 사설망)**의 정의와 특징을 설명하고 있기 때문입니다.

VPN은 사설 네트워크(Private Network)를 공용 네트워크(Public Network), 즉 주로 인터넷을 통해 **가상(Virtual)**으로 확장하고 연결하는 기술입니다.

VPN인 이유 (문장별 해석)
문장들을 조금 더 쉽게 풀어서 설명해 드릴게요.

1. "공용 네트워크를 통해 사설 네트워크를 확장하는 기술이다."
쉽게 말해: 인터넷(공용망) 위에 마치 개인 전용선이 있는 것처럼 안전한 터널을 만들어서, 회사나 집 같은 특정 사설망에 외부에서 접속할 수 있게 해주는 기술입니다.

이러한 '가상의(Virtual)' 연결을 통해 '사설(Private)' 네트워크를 구축하는 것이 VPN의 핵심 목표입니다.

2. "사용자의 IP 주소를 숨기고, 사용자가 어디에서 접속하는지 추적하기 어렵게 만든다."
쉽게 말해: 사용자의 데이터가 VPN 서버를 거쳐 인터넷으로 나가기 때문에, 외부 웹사이트나 서비스에서는 사용자의 실제 IP 주소 대신 VPN 서버의 IP 주소만 보게 됩니다.

이것이 VPN의 주요 보안 및 프라이버시 기능입니다.

3. "종류로는 IPsec 또는 SSL, L2TP 등이 있다."
쉽게 말해: VPN을 구현하는 데 사용되는 **기술(프로토콜)**의 종류를 나열한 것입니다.

IPsec (Internet Protocol Security): IP 계층에서 보안을 제공하는 프로토콜.

SSL/TLS (Secure Sockets Layer / Transport Layer Security): 웹 기반 VPN이나 원격 접속에 주로 사용되는 프로토콜.

L2TP (Layer 2 Tunneling Protocol): 터널링을 생성하는 프로토콜로, 보통 IPsec과 함께 사용되어 보안을 강화합니다.




Ad-hoc
1. "중앙 관리나 고정된 인프라 없이 임시로 구성되는 네트워크이다."
쉽게 말해: 와이파이 공유기(중앙 관리 장비)나 기지국(고정된 인프라) 같은 장비의 도움 없이, 필요할 때마다 **노드(스마트폰, 노트북, 센서 등)**들끼리 자발적으로 모여 네트워크를 만듭니다.

이것이 바로 '애드혹(Ad-hoc)'이라는 이름이 붙은 이유입니다.

2. "일반적으로 무선 통신을 통해 노드들이 직접 연결되어 데이터를 주고받는다."
쉽게 말해: 각 기기가 라우터 역할을 동시에 수행하면서, 데이터가 다른 기기들을 건너(Hop) 목적지까지 전달됩니다. 기지국을 거치지 않고 장치끼리 직접 연결되기 때문에 무선 메시(Mesh) 네트워크의 형태를 가집니다.

3. "긴급 구조, 긴급 회의, 군사적인 상황 등에서 유용하게 활용될 수 있다."
쉽게 말해: 재난 상황으로 인해 통신 인프라(기지국, 광케이블)가 파괴되거나, 군사 작전처럼 빠르게 이동해야 하는 환경에서는 고정된 인프라를 설치할 수 없습니다.

이럴 때 애드혹 네트워크는 장비들이 즉시 네트워크를 구성할 수 있도록 해주는 핵심 기술입니다.




IPSec
"Network layer에서 IP패킷을 암호화하고 인증하는 등의 보안을 위한 표준이다."

IPSec은 OSI 7계층 모델 중 **Network Layer (3계층)**에서 작동하여 IP 패킷 전체 또는 일부에 대한 암호화와 인증 기능을 제공하는 보안 표준입니다.

"기업에서 사설 인터넷망으로 사용할 수 있는 VPN을 구현하는데 사용되는 프로토콜이다."

IPSec은 **Virtual Private Network (VPN)**을 구현하는 데 가장 널리 사용되는 프로토콜 중 하나입니다. VPN을 통해 공용 인터넷망 위에서도 마치 사설망처럼 보안 터널을 만들어 안전하게 통신할 수 있게 해줍니다.

"AH(Authentication Header)와 ESP(Encapsulating Security Payload)라는 두 가지 보안 프로토콜을 사용한다."

IPSec은 실제로 두 가지 주요 프로토콜을 사용하여 보안 서비스를 제공합니다.

AH (Authentication Header): 데이터 무결성과 인증을 담당합니다. (암호화는 제공하지 않음)

ESP (Encapsulating Security Payload): 데이터 암호화와 무결성 및 인증을 제공하여 가장 널리 사용됩니다.




OAuth
비밀번호를 알려주지 않고도 다른 회사(앱)가 내 정보에 접근할 수 있게 해주는 약속 규칙"**인 OAuth

쉽게 말해, 어떤 앱(예: 배달 앱)에 가입할 때 **"카카오톡으로 로그인"**이나 **"구글로 로그인"**을 선택하는 과정을 생각해 보세요.

비밀번호를 안 알려줍니다: 배달 앱은 절대 사용자의 카카오톡 비밀번호를 알지 못합니다.

권한만 줍니다: 카카오톡은 배달 앱에게 **'접근 토큰'**이라는 일회용 열쇠를 줍니다. 이 열쇠는 사용자의 이름과 프로필 사진만 가져갈 수 있게 허락된 것입니다. (절대 비밀번호나 다른 민감한 정보는 못 가져갑니다.)

안전하게 사용합니다: 배달 앱은 이 열쇠(액세스 토큰)를 사용해서 카카오톡 서버에 있는 사용자 이름과 사진을 안전하게 가져와 로그인을 완료합니다.




ATM(Asynchronous Transfer Mode)

보통 인터넷에서는 데이터가 크기가 들쭉날쭉한 패킷(Packet) 형태로 전송됩니다. 하지만 ATM은 모든 데이터를 **'셀(Cell)'**이라는 아주 작은(53바이트) 고정 길이의 조각으로 잘라서 전송합니다.

ATM은 데이터를 보낼 때 '전화 통화'처럼 미리 경로를 설정하는 '연결 지향(Connection-Oriented)' 방식을 사용합니다.
데이터를 보내는 경로(가상 채널)를 미리 정해놓기 때문에, 셀들이 아무리 복잡한 망을 지나가도 순서가 섞이지 않고 도착합니다. 이는 음성 통화나 실시간 영상처럼 순서와 시간 지연이 중요한 서비스에 매우 유리합니다.

비동기적 (Asynchronous): 데이터를 보낼 때 정해진 시간 간격 없이, 보낼 데이터가 있을 때만 보내는 유연한 방식입니다.

통계적 다중화 (Statistical Multiplexing): 여러 사용자가 회선(채널)을 나눠서 효율적으로 사용하는 기술입니다. 회선을 비워두지 않고, 여러 사람이 동시에 데이터를 보낼 수 있도록 하여 통신 효율을 극대화합니다.


**흐름 제어(Flow Control)
네트워크에서 송신 속도보다 수신 속도가 느릴 때 발생하는 데이터 오버플로우를 막기 위해, 송수신 간 데이터 전송 속도나 양을 조절하는 기능
정지-대기(Stop-and-Wait): 한 번에 하나의 프레임만 보내고, 수신 확인(ACK)을 받은 후 다음 프레임을 보내는 방식.
슬라이딩 윈도우(Sliding Window): 여러 개의 프레임을 순차적으로 보내고, 일정 개수의 ACK를 받으면 윈도우를 이동시키는 방식 (Go-Back-N, Selective Repeat 등).





**NAT**는 쉽게 말해 사설 IP 주소를 공인 IP 주소로, 또는 그 반대로 변환해주는 기술입니다.


서브넷 마스크
https://www.youtube.com/watch?v=vPDQ4BpfymI
서브넷 : 1, 하나의 큰 네트워크를 몇개의 작은 회사한테 나누어 줄수 있냐
호스트 : 0, 한 회사 안에서 몇개 ip 주소를 가질수 있냐
네트워크 주소 : 시작 부분 주소
브로드캐스트 주소: 끝부분 주소
네트워크 : 한 회사



네트워크장비
p415
https://www.youtube.com/watch?v=QvttAz5B8ek
*허브 : 한 사무실이나 가까운 거리의 컴퓨터들을 연결하는 장치. 물리계층
컴퓨터 1~3 개는 공유기 연결하면 끝. 컴퓨터 100~200개 있다 할때 쓰임.
dummy hub: 단순이 연결만 함. 
switch hub: 연결한 컴퓨터 MAC addr 구분함. HW 방식. 요즘방식

*Bridge : LAN 과 LAN 을 연결 하거나, LAN 안에서의 컴퓨터 그룹(세그먼트)를 연결. SW 에서 작동함. 옛날방식.
data link layer.
같은 서브넷 안에서 멀티탭같이 연결 해주는놈.
물리적으로 떨어진 두 구역을 연결해서, 마치 한 사무실(같은 서브넷)인 것처럼 쓰게 해 준다.
졸라 쉽게 생각하면 한 회사 건물 안에서 부서만 나눈것. 두 부서간 연결

* Router: LAN 과 LAN + 최적 경로선택 + LAN + WAN
network layer.
접속 가능한 경로에 대한 routing table을 가지고 있음. 
L3, L4 스위치도 Router 에 포함.
그냥 라우터와 L3,L4 스위치는 용도가 다름.
L3,L4 스위치는 속도에 몰빵함.
라우터는 일반 인터넷 연결.

* Gateway
네트워크 진입점: 외부 네트워크로 나가기 위한 관문 역할을 수행합니다. (Default Gateway)

프로토콜 변환: OSI 전 계층(1~7)에 걸쳐 서로 다른 통신 규약을 호환되도록 변환합니다. (예: TCP/IP 네트워크 ↔ 비 TCP/IP 네트워크)

L1부터 L7까지 어느 계층에서든 존재할 수 있음


* 인터넷 세상:
최상위: ICANN(인터넷 재단)이 한국인터넷진흥원(KISA)에 IP 뭉텅이를 줌. 국가한테 **여의도만한 땅(초대형 IP 대역)**을 줍니다.

ISP: KISA가 SKT/KT에게 IP를 나눠줌. (서브넷팅으로 ip 만듬)

라우터: SKT/KT는 백본 라우터(졸라 큰 라우터)를 통해 미국 통신사와 연결됨.

할당: 우리 집 공유기가 켜지면 SKT의 DHCP 서버가 공인 IP 1개를 빌려줌.

절약 (핵심): 우리 집 공유기는 NAT 기술을 사용해, 이 공인 IP 1개로 내 폰, PC, 태블릿이 다 인터넷을 할 수 있게 해 줌. (서브네팅 아님!)
